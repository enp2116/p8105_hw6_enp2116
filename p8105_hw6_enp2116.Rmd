---
title: "p8105_hw6_enp2116"
author: "Emily Potts"
date: "2022-11-30"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(p8105.datasets)
library(tidyverse)
library(stats)
library(modelr)
library(mgcv)

set.seed(4)

```

# Problem 1
```{r}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2017-01-01",
    date_max = "2017-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
```

simple linear regression with tmax as the response and tmin as the predictor, and are interested in the distribution of two quantities estimated from these data:
* $\hat{r^2}$
* $log(\hat{\beta_0 * \beta_1})$

Use 5000 bootstrap samples and, for each bootstrap sample, produce estimates of these two quantities. Plot the distribution of your estimates, and describe these in words. Using the 5000 bootstrap estimates, identify the 2.5% and 97.5% quantiles to provide a 95% confidence interval for $\hat{r^2}$
 and $log(\hat{\beta_0 * \beta_1})$). Note: broom::glance() is helpful for extracting r̂2
 from a fitted regression, and broom::tidy() (with some additional wrangling) should help in computing $log(\hat{\beta_0 * \beta_1})$


# Problem 2
Washington Post homicides:

Creating a city_state variable and a binary variable (outcome) indicating whether the homicide is solved. Omitting cities Dallas, TX; Phoenix, AZ; Kansas City; and MO Tulsa, AL. Limiting analysis those for whom victim_race is white or black, and making sure that victim_age is numeric.
```{r, warning = FALSE}
tidy_homicide = 
  read_csv("data/homicide-data.csv") %>% 
  mutate(
    city_state = paste(city, state, sep = ", "),
    resolved = as.numeric(disposition == "Closed by arrest"),
    victim_age = as.numeric(victim_age)) %>% 
  filter(!city_state %in% c("Dallas, TX", "Phoenix, AZ", "Kansas City, MO", "Tulsa, AL")) %>% 
  filter(victim_race  %in% c( "Black", "White"))
```

For the city of Baltimore, MD, using the glm function to fit a logistic regression with resolved vs unresolved as the outcome and victim age, sex and race as predictors. Saving the output of glm as an R object; applying the broom::tidy to this object; and obtaining the estimate and confidence interval of the adjusted odds ratio for solving homicides comparing male victims to female victims keeping all other variables fixed:
```{r}
balt_log_fit = 
  tidy_homicide %>% 
  filter(city_state == "Baltimore, MD") %>% 
  glm(resolved ~ victim_age + victim_race + victim_sex, data = ., family = binomial()) 

balt_log_fit %>% 
  broom::tidy() %>% 
  mutate(OR = exp(estimate),
         est_low_CI = estimate - std.error * qnorm(0.975),
         est_high_CI = estimate + std.error * qnorm(0.975),
         OR_low_CI = exp(est_low_CI),
         OR_high_CI = exp(est_high_CI),
         ) %>% 
  filter(term == "victim_sexMale") %>% 
  select(term, OR, OR_low_CI, OR_high_CI, p.value) %>% 
  knitr::kable(digits = 3)
```
We are 95% confident that the adjusted odds ratio for solving homicides comparing male victims to female victims keeping victim race and age fixed is between 0.325 and 0.558. This means that when controlling for the impacts of other victim-related variables, homicides in which the victims are male are substantially less likely to be resolved that those in which the victim is female.

Now running glm for each of the cities in my dataset, and extracting the adjusted odds ratio (and CI) for solving homicides comparing male victims to female victims. Do this within a “tidy” pipeline, making use of purrr::map, list columns, and unnest as necessary to create a dataframe with estimated ORs and CIs for each city.
```{r}
city_state_glms =
  tidy_homicide %>% 
  nest(data = -city_state) %>% 
  mutate(
    glms = map(data, ~glm(resolved ~ victim_age + victim_race + victim_sex, data = ., family = binomial())),
    results = map(glms, broom::tidy)) %>% 
  select(-data, -glms) %>% 
  unnest(results) %>% 
  filter(term == "victim_sexMale") %>% 
  mutate(OR = exp(estimate),
         est_low_CI = estimate - std.error * qnorm(0.975),
         est_high_CI = estimate + std.error * qnorm(0.975),
         OR_low_CI = exp(est_low_CI),
         OR_high_CI = exp(est_high_CI),
         ) %>% 
  select(city_state, term, OR, OR_low_CI, OR_high_CI, p.value) 
head(city_state_glms)
```

Create a plot that shows the estimated ORs and CIs for each city. Organize cities according to estimated OR, and comment on the plot.

```{r}
city_state_glms %>% 
  mutate(city_state = forcats::fct_reorder(city_state, OR)) %>% 
  ggplot(aes(x = city_state, y = OR, color = city_state)) + geom_point() + geom_errorbar(aes(ymin = OR_low_CI, ymax = OR_high_CI)) +
  theme(axis.text.x = element_text(angle = 80, hjust = 1, size = 7))  + 
  labs(
    title = "Adjusted Odds Ratios for Male to Female Solved Homicides",
    x = "Location (City, State)",
    y = "Adjusted OR and 95% CI"
    ) +  
  theme(legend.position = "None")
```
Based on the plot, we can see that the majority of cities have an adjusted odds ratio less than 1, indicating that when controlling for the impacts of other victim-related variables, homicides in which the victims are male are less likely to be resolved that those in which the victim is female. We do however, see some cities with quite wide 95% CIs for this odds ratio. This occurs primarily in cities that have the highest male to female adjusted ORs (the right side of the graph).


# Problem 3
Loading and clean the data for regression analysis (i.e. convert numeric to factor where appropriate, check for missing data, etc.).
```{r, message = FALSE}
tidy_birthweight =
  read_csv("data/birthweight.csv", col_types = "fnnnnnfnfnnnfnnnnnnnn")

tidy_birthweight %>% summarise_all(list(name = ~sum(is.na(.))/length(.)))
```

Propose a regression model for birthweight. This model may be based on a hypothesized structure for the factors that underly birthweight, on a data-driven model-building process, or a combination of the two. 
```{r}
bw_reg_model = 
  tidy_birthweight %>% 
  lm(data = ., bwt ~ blength + delwt + gaweeks + fincome + malform + momage + mrace + parity + ppwt + smoken) %>% 
  summary()
```
I built my proposed model using backward elimination, initially starting with the variables of blength, delwt, gaweeks, fincome , malform, momage, mrace, parity, ppwt, and smoken. I chose these variables based on recent literature indicating that both baby () and mother centric (both health and situational) measures are linked to a baby's low birthweight.

Describe your modeling process and show a plot of model residuals against fitted values – use add_predictions and add_residuals in making this plot.
```{r}

```


Compare your model to two others:

One using length at birth and gestational age as predictors (main effects only)
```{r}
main_effects_mod = 
  tidy_birthweight %>% 
  lm(data = ., bwt ~ blength + gaweeks) 
```

One using head circumference, length, sex, and all interactions (including the three-way interaction) between these
```{r}
interaction_mod = 
  tidy_birthweight %>% 
  lm(data = ., bwt ~ bhead*blength*babysex)
```

Make this comparison in terms of the cross-validated prediction error; use crossv_mc and functions in purrr as appropriate.
```{r}
cv_df =
  crossv_mc(tidy_birthweight, 100) %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble))
```

```{r}
cv_df = 
  cv_df %>% 
  mutate(
    bw_reg_model  = map(train, ~lm(data = ., bwt ~ mrace + gaweeks)),
    main_effects_mod   = map(train, ~lm(data = ., bwt ~ blength + gaweeks)),
    interaction_mod  = map(train, ~lm(data = ., bwt ~ bhead*blength*babysex))) %>% 
  mutate(
    rmse_bw_reg = map2_dbl(bw_reg_model, test, ~rmse(model = .x, data = .y)),
    rmse_main_effects  = map2_dbl(main_effects_mod, test, ~rmse(model = .x, data = .y)),
    rmse_interaction = map2_dbl(interaction_mod, test, ~rmse(model = .x, data = .y)))
```

Violin plot showing the prediction error distribution for each candidate model:
```{r}
cv_df %>% 
  select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()
```



